// Let F be a PRF that takes two inputs: a key and a message
// Imagine a scenario where a user generates a fresh secret key k and then lets the adversary obtain F(k, m) for messages m of its choosing
// The adversary should not know F(k, m') for any message m' it didn't previously ask

theory basic_prf
begin

// declare our basic function f taking two inputs
functions: f/2

// we'll have a first rule that models honest parties generating secret keys
// each time it's run, it will generate a fresh key and corresponding key identitier, and return the key identifier to the adversary
// it records the mapping between keyid and key in a permanent fact KeyMapping so that this can be used as input to later rules
// it also records an action fact ("KeyGenerated") recording the mapping between keyid and key; we have to do this because our lemmas can only refer to action facts
rule GenKey:
  [Fr(~k), Fr(~keyid)]
  --[KeyGenerated(~keyid, ~k)]->
  [Out(~keyid), !KeyMapping(~keyid, ~k)]

// we'll have another rule that models the adversary being able to get outputs generated for messages of their choice
// the adversary provides as input a tuple consisting of a message and a keyid
// we also need to lookup the key k corresponding to that keyid, which we do using the permanent KeyMapping fact we produced during GenKey
// we return f(k, m) to the adversary
// we also record as an action fact a log event saying that we F(k, m) for the adversary for this keyid and message (Applied(keyid, m))
rule ApplyF:
  [In(<m, keyid>), !KeyMapping(keyid, k)]
  --[Applied(keyid, m)]->
  [Out(f(k, m))]

// here's our first attempt at defining security
// this lemma says that, for all keyid's and keys k generated by during GenKey, there is no point in time at which there exists a message m such that the adversary knows f(k, m)  (recall that "K" means "knows")
// this lemma doesn't actually hold -- think about it why
// then run "tamarin-prover interactive ." and try to get Tamarin to prove this lemma; it should fail and produce a trace
// does the attack in the trace make sense to you? does it match your intuition?
lemma unknown_attempt1:
  "
    All keyid k #tkeygen
    .
    KeyGenerated(keyid, k) @ #tkeygen
    ==> 
    not(Ex m #t . K(f(k, m)) @ #t)
  "

// let's try to fix the lemma
// our new idea is: for any honestly generated key k, the adversary should only know f(k, m) if it queried m to the ApplyF oracle
// stated in a different but logically equivalent way: for all keys k and messages m, if k was honestly generated, then the adversary should not know f(k, m) if it did not query m to the ApplyF oracle
// or another different but logically equivalent way: for all keys k and messages m, if k was honestly generated and the adversary knows f(k, m),then the adversary must have queried m to the ApplyF oracle
// (in fact we can be even more precise: the adversary must have queried m to the ApplyF oracle before the time at which it knew f(k, m))
lemma unknown_attempt2:
  "
    All keyid k m #tkeygen #tknows
    .
    KeyGenerated(keyid, k) @ #tkeygen
    & K(f(k, m)) @ #tknows
    ==> 
    Ex #tqueried . #tqueried < #tknows & Applied(keyid, m) @ #tqueried
"

end